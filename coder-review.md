# Code Review

## Общее

- Так как это не GitHub|Gitlab, формат ревью абсолютно вольный с пояснениями и комментированием своих правок - подразумевается, что я не только веду ревью, но и общаюсь с автором кода. В боевой среде я бы конкретно указывал на строки|блоки|файлы и конкретные проблемы.
- Я во многих местах опущу детские вещи (например опечатки). Где нашел - исправил, а цепляться буду к смыслу.
- Для простоты, все исключения в проекте будут сводиться к \Exception. По их обработке подробности в [логировании](#логирование).

### Краткое резюме

Проект - мешанина между MVC и DDD, с нарушениями структурного и семантического характера. Так как проект лёгкий, обладает в сути одним контекстом и по факту является микросервисом, DDD нам не нужен, то _**я предлагаю следовать MVC**_.

Далее будут упоминаться тонкости в моментах в качестве ликбеза, но все правки будут именно в сторону MVC. Так же по причине того, что у проекта нет ядра, единой точки входа и Dependency Injection (здесь и далее DI или DIP, если мы говорим о DI как о принципе SOLID), но я, как сказано по заданию, буду подразумевать, что они есть и проблем там нет.

## Контроллеры

1. Общее: чрезмерный дубляж кода по сборке ответов и это нарушение Single Responsibility Principle (далее SRP) - контроллер НЕ ДОЛЖЕН заниматься сборкой ответа. 
2. `src/Controller/*` - здесь НЕ ДОЛЖЕН лежать код, который не связан с непосредственно контроллерами.
3. `src/Controller/GetProductsController.php` - нарушение семантики и информационная несогласованность. Внутри контроллер отдает продукты **по категориям**, а название это не отражает.
4. `src/Controller/AddToCartController.php` - нарушение SRP. Контроллер НЕ ДОЛЖЕН заниматься бизнес-логикой, а контроллер тут и достает продукт и кладёт его в корзину. Вынес логику в CartManager (но к нему еще вернёмся в [модели](#модель)). 

---

- Контроллеры приведены к тонкому состоянию и теперь выполняют только свою функцию.
- Вынес всё лишнее на свои места.
- Так же разбил контроллеры на смысловые группы.

Текущая реализация основана на action-based подходе: есть `DefaultController` (хранит модули, нужные только контроллерам), в нём уже есть контракт `Responder`, а сами контроллеры выполнены аля действия. `Responder` уже ожидает только DTO, подробнее в [представлении](#представление).

Бонусом в `DefaultController` добавлена инъекция контракта `Session` (и простейшая реализация), чтобы была видна явная работа слоев MVC и на основе чего мы получаем корзину из Redis.

## Модель

> Не стал всю модель запихивать под `src/Model` из-за малых размеров проекта, но считайте, что каталоги `Model`, `Repository` и `Service` относятся к Model по MVC.

### Репозитории

`src/Repository` - тут всё очень плохо. Лежит сервис модели, сущность и репозиторий, повязанный с инфраструктурой.
Теперь здесь лежат только контракты репозиториев, реализации поставляются через DI. А реализации вынесены на свои места и занимается только своим делом. Подробности по реализациям уже в [инфраструктуре](#инфраструктура).

### Сущности

`src/Domain` - перенесено в логичный для MVC `src/Model`, а сам каталог хранит только сущности (разбиты на группы по смыслам).

`src/Model/CartItem` - переименован в Item, т.к. по неймспейсу уже понятно к чему относится. И внесена внутрь логика подсчета общей суммы (её НЕ ДОЛЖЕН рассчитывать внешний код).

`src/Model/Customer` - аналогично предыдущему, внесена внутрь логика получения ФИО.

`src/Model/Cart`:
- Объект не контролирует свое состояние - речь про Items. Корзина по факту делегирует изменение позиций на внешний код, хотя должна сама это контролировать на основе добавляемых продуктов. Исправлено и добавлен гарант инварианта в конструктор - отказаться от $items в конструкторе мы не можем, т.к. туда напрямую их устанавливает сборщик сущности в контексте работы с Redis (но вынести на инъекцию через Reflection API в будущем можно).

`src/Model/PaymentMethod` - вынесен явный Enum, что гарантирует инвариант в корзине.

### CartManager

Достоин отдельного разбора.

1. Неправильное местоположение. Ему место либо в сервисах (если мы следуем MVC), либо в слое приложения (если снова вспомним DDD).
2. Нарушение и SRP и DIP. CartManager и **_сохраняет_** данные, и знает **_как_** это делать.
3. Явная анемия - в сервисе по работе с корзиной... нет логики работы с корзиной - она вся в контроллерах.
4. В продолжение предыдущему нарушен принцип _Tell. Don't Ask_ - контроллер, работающий с сервисом, сам вытаскивает корзину и модифицирует её.

Я его вынес в положенное ему место - `src/Service` и переименовал в `CartService`. Теперь занимается он теперь только бизнес-логикой. Разорвал связность с инфраструктурой - сейчас она зависит от модели, а не наоборот. А представление в виде ассемблеров DTO теперь являются логичным продолжением работы модели (об этом так же подробнее в [представлении](#представление)).

Аналогично выполнен `CatalogService`, который ответственен за бизнес-логику с продуктами, но там всё сильно проще.

## Инфраструктура

Каталог `src/Infrastructure` расширен и разбит на смысловые каталоги. Там лежат только инфраструктурные модули и реализации контрактов.

### Redis 

> **ВАЖНО**: из-за того, что я не имел боевого опыта с Redis и где-то могу не знать как **_в действительности_** с ним взаимодействовать, я опущу некоторые моменты. В коде это будет видно по комментариям.

`Redis\ConnectorFacade`: конкретно здесь фасад кривой и трудно поддерживаемый:
- Сборка фасада (метод `build()`) почему-то ушла на ответственность конкретной реализации;
- Конкретной реализации достаточно знать только ID таблицы, данные для подключения ей не нужны;
- Крайне непрозрачная логика сборки фасада, сам метод раздут и нарушает SRP.

`Redis\Connector`:
- Дырявая абстракция - класс почему-то знает об объекте корзины.
- Магия - время жизни сущности зашито расчётом в код. Еще веселее то, что коннектор НЕ ДОЛЖЕН знать о времени жизни корзины и о корзине вообще.

---

Изменён сам принцип работы - фасад заменен на `ConnectorProvider`, который предоставляет функционал для работы с Redis, а его уже использует redis-реализация контракта репозитория. Данные для подключения поставляются через `Redis\Connection`.

И из своих предположений, что внутрь-наружу Redis гоняются сырые данные, появился `src\Infrastructure\Redis\Assembler\CartAssembler`, который конвертирует их туда-обратно.

`Redis\ConnectorException`: убран за ненадобностью. Подробности в [логировании](#логирование)

## Представление

Оба класса `CartView` и `ProductView` - отличные примеры дырявой абстракции. Они НЕ ДОЛЖНЫ знать ничего о более высокоуровневом слое (репозитории, который относится к модели) - допустимы зависимости только от сервисов, и то не желательно и зависит от договоренности.

В идеале у нас должна быть следующая логика:

```plaintext
         |          Controller          |
         ↓                              ↓
Request -> Service -> View -> Responder -> Response
              ↑         ↑
            Model      DTO         
```

- Controller передаёт ввод в Service;
- Service выполняет бизнес-логику и передает результат в View;
- View конвертирует результат в DTO и отдает его Controller;
- Controller передает результат в Responder, где формируется окончательный HTTP-ответ.

Допускается, что контроллер может собрать примитивный DTO для Responder самостоятельно, но в продуктовых условиях лучше централизовать сборку ответов.

---

Старый код сожжен.

- В `src/View` появляются Assembler'ы, которые конвертируют бизнес-сущности в DTO, что гарантирует безопасность и отделяет модель от представления;
- Появился набор DTO в `src/View/DTO`.

> **ВАЖНО**: я постарался не нарушать текущую структуру JSON, которая используется в проекте. Это важно для сохранения работоспособности интерфейса веб-приложения и вообще хороший тон, особенно если нет явного версионирования.

Для последнего отмечу, что JsonResponder преобразует в тело ответа весь вход через `json_encode`, который достаточно всеяден и гибок. Мы можем свободно пользоваться его преимуществами - DTO, которые в JSON имеют нестандартную структуру, реализуют контракт `\JsonSerializable` и соответствующую кастомизацию.

## Логирование

Уделил этому отдельный раздел:
- Покрытие явно недостаточное и затрагивает только CartManager.
- Покрытие некорректное: любые исключения вызывают логгер и всё - далее поведение API абсолютно непрогнозируемое.

Из-за того, что кроме факта отлова ошибок других пояснений в задаче нет, я предлагаю следующий вариант:
- Единая точка записи - Middleware. И в идеале через него можно реализовать паттерн API Problem, чтобы централизовать выдачу ответов-исключений.
- Запись базируется на выбросе исключений - гарантирует остановку бизнес-сценария. Я не буду тут реализовывать семейство ошибок - где надо будет бросаться базовый \Exception. Но подразумевается, что в проекте можно завести типизированное семейство исключений и за счет него вести эффективное логирование.
- Исключения бросаются ТОЛЬКО на уровне инфраструктуры и модели. В слое презентации подразумевается, что всё отработано штатно и внутри слоя только корректные данные.
- Запись только одного уровня - error (ошибка в процессе). В идеале нужно хотя бы 3 (debug|info для штатной обработки, error для ожидаемых и critical для неожидаемых).

> ВАЖНО: Я реализовал примитивный Middleware для наглядности. Он не соблюдает PSR-15, но я решил не насиловать composer.json добавлением PSR-библиотеки. Просто примем, что в идеале, раз проект следует PSR, то можно сразу сделать PSR-реализацию.

Да, это немного выходит за рамки задания - Middleware уже залезает на уровень фреймворка, но я считаю важным показать минимально корректный подход к логированию, а на одних контроллерах это продемонстрировать проблематично.

## Postskriptum (не по сути задания)

- migrations/schema.init.sql:7 - в запросе явная ошибка: в MySQL 8+ поля с типом TEXT не поддерживают из коробки default-значения, для этого нужно дополнительно конфигурировать MySQL. Исправил удалением default-выражения. Но потенциально под названия товаров/услуг типа VARCHAR оговоренной длины более чем достаточно, а тип данных TEXT крайне избыточен.
